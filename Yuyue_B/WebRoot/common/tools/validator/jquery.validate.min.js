/*
 * jQuery validation plug-in 1.5.5
 *
 * http://bassistance.de/jquery-plugins/jquery-plugin-validation/
 * http://docs.jquery.com/Plugins/Validation
 *
 * Copyright (c) 2006 - 2008 Jörn Zaefferer
 *
 * $Id: jquery.validate.min.js,v 1.6 2011/11/28 03:03:19 wangzy Exp $
 *
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 */
(function($) {
	$
			.extend(
					$.fn,
					{
						validate : function(options) {
							if (!this.length) {
								options
										&& options.debug
										&& window.console
										&& console
												.warn("nothing selected, can't validate, returning nothing");
								return;
							}
							var validator = $.data(this[0], 'validator');
							if (validator) {
								return validator;
							}
							validator = new $.validator(options, this[0]);
							$.data(this[0], 'validator', validator);
							if (validator.settings.onsubmit) {
								this.find("input, button").filter(".cancel")
										.click(function() {
											validator.cancelSubmit = true;
										});
								if (validator.settings.submitHandler) {
									this.find("input, button")
											.filter(":submit")
											.click(function() {
												validator.submitButton = this;
											});
								}
								this
										.submit(function(event) {
											if (validator.settings.debug)
												event.preventDefault();
											function handle() {
												if (validator.settings.submitHandler) {
													if (validator.submitButton) {
														var hidden = $(
																"<input type='hidden'/>")
																.attr(
																		"name",
																		validator.submitButton.name)
																.val(
																		validator.submitButton.value)
																.appendTo(
																		validator.currentForm);
													}
													validator.settings.submitHandler
															.call(
																	validator,
																	validator.currentForm);
													if (validator.submitButton) {
														hidden.remove();
													}
													return false;
												}
												return true;
											}
											if (validator.cancelSubmit) {
												validator.cancelSubmit = false;
												return handle();
											}
											if (validator.form()) {
												if (validator.pendingRequest) {
													validator.formSubmitted = true;
													return false;
												}
												return handle();
											} else {
												validator.focusInvalid();
												return false;
											}
										});
							}
							return validator;
						},
						valid : function() {
							if ($(this[0]).is('form')) {
								return this.validate().form();
							} else {
								var valid = true;
								var validator = $(this[0].form).validate();
								this.each(function() {
									valid &= validator.element(this);
								});
								return valid;
							}
						},
						removeAttrs : function(attributes) {
							var result = {}, $element = this;
							$.each(attributes.split(/\s/), function(index,
									value) {
								result[value] = $element.attr(value);
								$element.removeAttr(value);
							});
							return result;
						},
						rules : function(command, argument) {
							var element = this[0];
							if (command) {
								var settings = $
										.data(element.form, 'validator').settings;
								var staticRules = settings.rules;
								var existingRules = $.validator
										.staticRules(element);
								switch (command) {
								case "add":
									$.extend(existingRules, $.validator
											.normalizeRule(argument));
									staticRules[element.name] = existingRules;
									if (argument.messages)
										settings.messages[element.name] = $
												.extend(
														settings.messages[element.name],
														argument.messages);
									break;
								case "remove":
									if (!argument) {
										delete staticRules[element.name];
										return existingRules;
									}
									var filtered = {};
									$
											.each(
													argument.split(/\s/),
													function(index, method) {
														filtered[method] = existingRules[method];
														delete existingRules[method];
													});
									return filtered;
								}
							}
							var data = $.validator.normalizeRules($.extend( {},
									$.validator.metadataRules(element),
									$.validator.classRules(element),
									$.validator.attributeRules(element),
									$.validator.staticRules(element)), element);
							if (data.required) {
								var param = data.required;
								delete data.required;
								data = $.extend( {
									required : param
								}, data);
							}
							return data;
						}
					});
	$.extend($.expr[":"], {
		blank : function(a) {
			return !$.trim(a.value);
		},
		filled : function(a) {
			return !!$.trim(a.value);
		},
		unchecked : function(a) {
			return !a.checked;
		}
	});
	$.validator = function(options, form) {
		this.settings = $.extend( {}, $.validator.defaults, options);
		this.currentForm = form;
		this.init();
	};
	$.validator.format = function(source, params) {
		if (arguments.length == 1)
			return function() {
				var args = $.makeArray(arguments);
				args.unshift(source);
				return $.validator.format.apply(this, args);
			};
		if (arguments.length > 2 && params.constructor != Array) {
			params = $.makeArray(arguments).slice(1);
		}
		if (params.constructor != Array) {
			params = [ params ];
		}
		$.each(params, function(i, n) {
			source = source.replace(new RegExp("\\{" + i + "\\}", "g"), n);
		});
		return source;
	};
	$
			.extend(
					$.validator,
					{
						defaults : {
							messages : {},
							groups : {},
							rules : {},
							errorClass : "error",
							validClass : "valid",
							errorElement : "label",
							focusInvalid : true,
							errorContainer : $( []),
							errorLabelContainer : $( []),
							onsubmit : true,
							ignore : [],
							ignoreTitle : false,
							onfocusin : function(element) {
								this.lastActive = element;
								if (this.settings.focusCleanup
										&& !this.blockFocusCleanup) {
									this.settings.unhighlight
											&& this.settings.unhighlight.call(
													this, element,
													this.settings.errorClass,
													this.settings.validClass);
									this.errorsFor(element).hide();
								}
							},
							onfocusout : function(element) {
								if (!this.checkable(element)
										&& (element.name in this.submitted || !this
												.optional(element))) {
									this.element(element);
								}
							},
							onkeyup : function(element) {
								if (element.name in this.submitted
										|| element == this.lastElement) {
									this.element(element);
								}
							},
							onclick : function(element) {
								if (element.name in this.submitted)
									this.element(element);
							},
							highlight : function(element, errorClass,
									validClass) {
								$(element).addClass(errorClass).removeClass(
										validClass);
							},
							unhighlight : function(element, errorClass,
									validClass) {
								$(element).removeClass(errorClass).addClass(
										validClass);
							}
						},
						setDefaults : function(settings) {
							$.extend($.validator.defaults, settings);
						},
						messages : {
							required : "This field is required.",
							remote : "Please fix this field.",
							email : "Please enter a valid email address.",
							url : "Please enter a valid URL.",
							date : "Please enter a valid date.",
							dateISO : "Please enter a valid date (ISO).",
							dateDE : "Bitte geben Sie ein gültiges Datum ein.",
							number : "Please enter a valid number.",
							numberDE : "Bitte geben Sie eine Nummer ein.",
							digits : "Please enter only digits",
							creditcard : "Please enter a valid credit card number.",
							equalTo : "Please enter the same value again.",
							accept : "Please enter a value with a valid extension.",
							maxlength : $.validator
									.format("Please enter no more than {0} characters."),
							minlength : $.validator
									.format("Please enter at least {0} characters."),
							rangelength : $.validator
									.format("Please enter a value between {0} and {1} characters long."),
							range : $.validator
									.format("Please enter a value between {0} and {1}."),
							max : $.validator
									.format("Please enter a value less than or equal to {0}."),
							min : $.validator
									.format("Please enter a value greater than or equal to {0}."),
							maxbytelen : jQuery.validator
									.format("请输入一个长度最多是 {0} 字节数的字符串"),
							minbytelen : jQuery.validator
									.format("请输入一个长度最少是 {0} 字节数的字符串"),
							rangebytelen : jQuery.validator
									.format("请输入一个长度介于 {0} 和 {1} 字节数之间的字符串"),
							alpnum : jQuery.validator.format("请输入数字或者字母"),
							chinese : jQuery.validator.format("请输入中文")
						},
						autoCreateRanges : false,
						prototype : {
							init : function() {
								this.labelContainer = $(this.settings.errorLabelContainer);
								this.errorContext = this.labelContainer.length
										&& this.labelContainer
										|| $(this.currentForm);
								this.containers = $(
										this.settings.errorContainer).add(
										this.settings.errorLabelContainer);
								this.submitted = {};
								this.valueCache = {};
								this.pendingRequest = 0;
								this.pending = {};
								this.invalid = {};
								this.reset();
								var groups = (this.groups = {});
								$.each(this.settings.groups, function(key,
										value) {
									$.each(value.split(/\s/), function(index,
											name) {
										groups[name] = key;
									});
								});
								var rules = this.settings.rules;
								$.each(rules, function(key, value) {
									rules[key] = $.validator
											.normalizeRule(value);
								});
								function delegate(event) {
									var validator = $.data(this[0].form,
											"validator");
									validator.settings["on" + event.type]
											&& validator.settings["on"
													+ event.type].call(
													validator, this[0]);
								}
								$(this.currentForm)
										.delegate(
												"focusin focusout keyup",
												":text, :password, :file, select, textarea",
												delegate).delegate("click",
												":radio, :checkbox", delegate);
								if (this.settings.invalidHandler)
									$(this.currentForm).bind(
											"invalid-form.validate",
											this.settings.invalidHandler);
							},
							form : function() {
								this.checkForm();
								$.extend(this.submitted, this.errorMap);
								this.invalid = $.extend( {}, this.errorMap);
								if (!this.valid())
									$(this.currentForm).triggerHandler(
											"invalid-form", [ this ]);
								this.showErrors();
								return this.valid();
							},
							checkForm : function() {
								this.prepareForm();
								for ( var i = 0, elements = (this.currentElements = this
										.elements()); elements[i]; i++) {
									this.check(elements[i]);
								}
								return this.valid();
							},
							element : function(element) {
								element = this.clean(element);
								this.lastElement = element;
								this.prepareElement(element);
								this.currentElements = $(element);
								var result = this.check(element);
								if (result) {
									delete this.invalid[element.name];
								} else {
									this.invalid[element.name] = true;
								}
								if (!this.numberOfInvalids()) {
									this.toHide = this.toHide
											.add(this.containers);
								}
								this.showErrors();
								return result;
							},
							showErrors : function(errors) {
								if (errors) {
									$.extend(this.errorMap, errors);
									this.errorList = [];
									for ( var name in errors) {
										this.errorList.push( {
											message : errors[name],
											element : this.findByName(name)[0]
										});
									}
									this.successList = $
											.grep(
													this.successList,
													function(element) {
														return !(element.name in errors);
													});
								}
								this.settings.showErrors ? this.settings.showErrors
										.call(this, this.errorMap,
												this.errorList)
										: this.defaultShowErrors();
							},
							resetForm : function() {
								if ($.fn.resetForm)
									$(this.currentForm).resetForm();
								this.submitted = {};
								this.prepareForm();
								this.hideErrors();
								this.elements().removeClass(
										this.settings.errorClass);
							},
							numberOfInvalids : function() {
								return this.objectLength(this.invalid);
							},
							objectLength : function(obj) {
								var count = 0;
								for ( var i in obj)
									count++;
								return count;
							},
							hideErrors : function() {
								this.addWrapper(this.toHide).hide();
							},
							valid : function() {
								return this.size() == 0;
							},
							size : function() {
								return this.errorList.length;
							},
							focusInvalid : function() {
								if (this.settings.focusInvalid) {
									try {
										$(
												this.findLastActive()
														|| this.errorList.length
														&& this.errorList[0].element
														|| []).filter(
												":visible").focus();
									} catch (e) {
									}
								}
							},
							findLastActive : function() {
								var lastActive = this.lastActive;
								return lastActive
										&& $
												.grep(
														this.errorList,
														function(n) {
															return n.element.name == lastActive.name;
														}).length == 1
										&& lastActive;
							},
							elements : function() {
								var validator = this, rulesCache = {};
								return $( [])
										.add(this.currentForm.elements)
										.filter(":input")
										.not(
												":submit, :reset, :image, [disabled]")
										.not(this.settings.ignore)
										.filter(
												function() {
													!this.name
															&& validator.settings.debug
															&& window.console
															&& console
																	.error(
																			"%o has no name assigned",
																			this);
													if (this.name in rulesCache
															|| !validator
																	.objectLength($(
																			this)
																			.rules()))
														return false;
													rulesCache[this.name] = true;
													return true;
												});
							},
							clean : function(selector) {
								return $(selector)[0];
							},
							errors : function() {
								return $(this.settings.errorElement + "."
										+ this.settings.errorClass,
										this.errorContext);
							},
							reset : function() {
								this.successList = [];
								this.errorList = [];
								this.errorMap = {};
								this.toShow = $( []);
								this.toHide = $( []);
								this.formSubmitted = false;
								this.currentElements = $( []);
							},
							prepareForm : function() {
								this.reset();
								this.toHide = this.errors()
										.add(this.containers);
							},
							prepareElement : function(element) {
								this.reset();
								this.toHide = this.errorsFor(element);
							},
							check : function(element) {
								element = this.clean(element);
								if (this.checkable(element)) {
									element = this.findByName(element.name)[0];
								}
								var rules = $(element).rules();
								var dependencyMismatch = false;
								for (method in rules) {
									var rule = {
										method : method,
										parameters : rules[method]
									};
									try {
										var result = $.validator.methods[method]
												.call(this, element.value
														.replace(/\r/g, ""),
														element,
														rule.parameters);
										if (result == "dependency-mismatch") {
											dependencyMismatch = true;
											continue;
										}
										dependencyMismatch = false;
										if (result == "pending") {
											this.toHide = this.toHide.not(this
													.errorsFor(element));
											return;
										}
										if (!result) {
											this.formatAndAdd(element, rule);
											return false;
										}
									} catch (e) {
										this.settings.debug
												&& window.console
												&& console
														.log("exception occured when checking element "
																+ element.id
																+ ", check the '"
																+ rule.method
																+ "' method");
										throw e;
									}
								}
								if (dependencyMismatch)
									return;
								if (this.objectLength(rules))
									this.successList.push(element);
								return true;
							},
							customMetaMessage : function(element, method) {
								if (!$.metadata)
									return;
								var meta = this.settings.meta ? $(element)
										.metadata()[this.settings.meta] : $(
										element).metadata();
								return meta && meta.messages
										&& meta.messages[method];
							},
							customMessage : function(name, method) {
								var m = this.settings.messages[name];
								return m
										&& (m.constructor == String ? m
												: m[method]);
							},
							findDefined : function() {
								for ( var i = 0; i < arguments.length; i++) {
									if (arguments[i] !== undefined)
										return arguments[i];
								}
								return undefined;
							},
							defaultMessage : function(element, method) {
								return this.findDefined(this.customMessage(
										element.name, method), this
										.customMetaMessage(element, method),
										!this.settings.ignoreTitle
												&& element.title || undefined,
										$.validator.messages[method],
										"<strong>Warning: No message defined for "
												+ element.name + "</strong>");
							},
							formatAndAdd : function(element, rule) {
								var message = this.defaultMessage(element,
										rule.method);
								if (typeof message == "function")
									message = message.call(this,
											rule.parameters, element);
								this.errorList.push( {
									message : message,
									element : element
								});
								this.errorMap[element.name] = message;
								this.submitted[element.name] = message;
							},
							addWrapper : function(toToggle) {
								if (this.settings.wrapper)
									toToggle = toToggle.add(toToggle
											.parent(this.settings.wrapper));
								return toToggle;
							},
							defaultShowErrors : function() {
								for ( var i = 0; this.errorList[i]; i++) {
									var error = this.errorList[i];
									this.settings.highlight
											&& this.settings.highlight.call(
													this, error.element,
													this.settings.errorClass,
													this.settings.validClass);
									this
											.showLabel(error.element,
													error.message);
								}
								if (this.errorList.length) {
									this.toShow = this.toShow
											.add(this.containers);
								}
								if (this.settings.success) {
									for ( var i = 0; this.successList[i]; i++) {
										this.showLabel(this.successList[i]);
									}
								}
								if (this.settings.unhighlight) {
									for ( var i = 0, elements = this
											.validElements(); elements[i]; i++) {
										this.settings.unhighlight.call(this,
												elements[i],
												this.settings.errorClass,
												this.settings.validClass);
									}
								}
								this.toHide = this.toHide.not(this.toShow);
								this.hideErrors();
								this.addWrapper(this.toShow).show();
							},
							validElements : function() {
								return this.currentElements.not(this
										.invalidElements());
							},
							invalidElements : function() {
								return $(this.errorList).map(function() {
									return this.element;
								});
							},
							showLabel : function(element, message) {
								var label = this.errorsFor(element);
								if (label.length) {
									label.removeClass().addClass(
											this.settings.errorClass);
									label.attr("generated")
											&& label.html(message);
								} else {
									label = $(
											"<" + this.settings.errorElement
													+ "/>").attr( {
										"for" : this.idOrName(element),
										generated : true
									}).addClass(this.settings.errorClass).html(
											message || "");
									if (this.settings.wrapper) {
										label = label.hide().show().wrap(
												"<" + this.settings.wrapper
														+ "/>").parent();
									}
									if (!this.labelContainer.append(label).length)
										this.settings.errorPlacement ? this.settings
												.errorPlacement(label,
														$(element))
												: label.insertAfter(element);
								}
								if (!message && this.settings.success) {
									label.text("");
									typeof this.settings.success == "string" ? label
											.addClass(this.settings.success)
											: this.settings.success(label);
								}
								this.toShow = this.toShow.add(label);
							},
							errorsFor : function(element) {
								return this.errors().filter(
										"[for='" + this.idOrName(element)
												+ "']");
							},
							idOrName : function(element) {
								return this.groups[element.name]
										|| (this.checkable(element) ? element.name
												: element.id || element.name);
							},
							checkable : function(element) {
								return /radio|checkbox/i.test(element.type);
							},
							findByName : function(name) {
								var form = this.currentForm;
								return $(document.getElementsByName(name)).map(
										function(index, element) {
											return element.form == form
													&& element.name == name
													&& element || null;
										});
							},
							getLength : function(value, element) {
								switch (element.nodeName.toLowerCase()) {
								case 'select':
									return $("option:selected", element).length;
								case 'input':
									if (this.checkable(element))
										return this.findByName(element.name)
												.filter(':checked').length;
								}
								return value.length;
							},
							depend : function(param, element) {
								return this.dependTypes[typeof param] ? this.dependTypes[typeof param]
										(param, element)
										: true;
							},
							dependTypes : {
								"boolean" : function(param, element) {
									return param;
								},
								"string" : function(param, element) {
									return !!$(param, element.form).length;
								},
								"function" : function(param, element) {
									return param(element);
								}
							},
							optional : function(element) {
								return !$.validator.methods.required.call(this,
										$.trim(element.value), element)
										&& "dependency-mismatch";
							},
							startRequest : function(element) {
								if (!this.pending[element.name]) {
									this.pendingRequest++;
									this.pending[element.name] = true;
								}
							},
							stopRequest : function(element, valid) {
								this.pendingRequest--;
								if (this.pendingRequest < 0)
									this.pendingRequest = 0;
								delete this.pending[element.name];
								if (valid && this.pendingRequest == 0
										&& this.formSubmitted && this.form()) {
									$(this.currentForm).submit();
								} else if (!valid && this.pendingRequest == 0
										&& this.formSubmitted) {
									$(this.currentForm).triggerHandler(
											"invalid-form", [ this ]);
								}
							},
							previousValue : function(element) {
								return $.data(element, "previousValue")
										|| $.data(element, "previousValue",
												previous = {
													old : null,
													valid : true,
													message : this
															.defaultMessage(
																	element,
																	"remote")
												});
							}
						},
						classRuleSettings : {
							required : {
								required : true
							},
							email : {
								email : true
							},
							url : {
								url : true
							},
							date : {
								date : true
							},
							dateISO : {
								dateISO : true
							},
							dateDE : {
								dateDE : true
							},
							number : {
								number : true
							},
							numberDE : {
								numberDE : true
							},
							digits : {
								digits : true
							},
							creditcard : {
								creditcard : true
							}
						},
						addClassRules : function(className, rules) {
							className.constructor == String ? this.classRuleSettings[className] = rules
									: $.extend(this.classRuleSettings,
											className);
						},
						classRules : function(element) {
							var rules = {};
							var classes = $(element).attr('class');
							classes
									&& $
											.each(
													classes.split(' '),
													function() {
														if (this in $.validator.classRuleSettings) {
															$
																	.extend(
																			rules,
																			$.validator.classRuleSettings[this]);
														}
													});
							return rules;
						},
						attributeRules : function(element) {
							var rules = {};
							var $element = $(element);
							for (method in $.validator.methods) {
								var value = $element.attr(method);
								if (value) {
									rules[method] = value;
								}
							}
							if (rules.maxlength
									&& /-1|2147483647|524288/
											.test(rules.maxlength)) {
								delete rules.maxlength;
							}
							return rules;
						},
						metadataRules : function(element) {
							if (!$.metadata)
								return {};
							var meta = $.data(element.form, 'validator').settings.meta;
							return meta ? $(element).metadata()[meta] : $(
									element).metadata();
						},
						staticRules : function(element) {
							var rules = {};
							var validator = $.data(element.form, 'validator');
							if (validator.settings.rules) {
								rules = $.validator
										.normalizeRule(validator.settings.rules[element.name])
										|| {};
							}
							return rules;
						},
						normalizeRules : function(rules, element) {
							$
									.each(
											rules,
											function(prop, val) {
												if (val === false) {
													delete rules[prop];
													return;
												}
												if (val.param || val.depends) {
													var keepRule = true;
													switch (typeof val.depends) {
													case "string":
														keepRule = !!$(
																val.depends,
																element.form).length;
														break;
													case "function":
														keepRule = val.depends
																.call(element,
																		element);
														break;
													}
													if (keepRule) {
														rules[prop] = val.param !== undefined ? val.param
																: true;
													} else {
														delete rules[prop];
													}
												}
											});
							$
									.each(
											rules,
											function(rule, parameter) {
												rules[rule] = $
														.isFunction(parameter) ? parameter(element)
														: parameter;
											});
							$.each( [ 'minlength', 'maxlength', 'min', 'max' ],
									function() {
										if (rules[this]) {
											rules[this] = Number(rules[this]);
										}
									});
							$.each( [ 'rangelength', 'range' ], function() {
								if (rules[this]) {
									rules[this] = [ Number(rules[this][0]),
											Number(rules[this][1]) ];
								}
							});
							if ($.validator.autoCreateRanges) {
								if (rules.min && rules.max) {
									rules.range = [ rules.min, rules.max ];
									delete rules.min;
									delete rules.max;
								}
								if (rules.minlength && rules.maxlength) {
									rules.rangelength = [ rules.minlength,
											rules.maxlength ];
									delete rules.minlength;
									delete rules.maxlength;
								}
							}
							if (rules.messages) {
								delete rules.messages
							}
							return rules;
						},
						normalizeRule : function(data) {
							if (typeof data == "string") {
								var transformed = {};
								$.each(data.split(/\s/), function() {
									transformed[this] = true;
								});
								data = transformed;
							}
							return data;
						},
						addMethod : function(name, method, message) {
							$.validator.methods[name] = method;
							$.validator.messages[name] = message
									|| $.validator.messages[name];
							if (method.length < 3) {
								$.validator.addClassRules(name, $.validator
										.normalizeRule(name));
							}
						},
						methods : {
							required : function(value, element, param) {
								if (!this.depend(param, element))
									return "dependency-mismatch";
								switch (element.nodeName.toLowerCase()) {
								case 'select':
									var options = $("option:selected", element);
									return options.length > 0
											&& (element.type == "select-multiple" || ($.browser.msie
													&& !(options[0].attributes['value'].specified) ? options[0].text
													: options[0].value).length > 0);
								case 'input':
									if (this.checkable(element))
										return this.getLength(value, element) > 0;
								default:
									return $.trim(value).length > 0;
								}
							},
							
							
				idCode : function(value, element, param) {
								
								if (this.optional(element))
									return "dependency-mismatch";
								var errMsg = {};
								var validator = this;
								var Errors=new Array("正确",
													 "身份证号码位数错误",
													 "身份证号码出生日期超出范围或含有非法字符",
													 "身份证号码校验位错误",
													 "身份证地区不合法");
								var area={11:"北京",12:"天津",13:"河北",14:"山西",15:"内蒙古",21:"辽宁",22:"吉林",
							23:"黑龙江",31:"上海",32:"江苏",33:"浙江",34:"安徽",35:"福建",36:"江西",37:"山东",
							41:"河南",42:"湖北",43:"湖南",44:"广东",45:"广西",46:"海南",50:"重庆",51:"四川",
							52:"贵州",53:"云南",54:"西藏",61:"陕西",62:"甘肃",63:"青海",64:"宁夏",65:"新疆",
							71:"台湾",81:"香港",82:"澳门",91:"国外"};
								var value,Y,JYM;
								var S,M;
								var value_array = new Array();
								value_array = value.split("");
//地区检验
								
if(area[parseInt(value.substr(0,2))]==null){
	this.settings.messages[element.name] =Errors[4]; 
	errMsg[element.name] =Errors[4];
	validator.showErrors(errMsg);
	return false;
};

//身份号码位数及格式检验

switch(value.length){

case 15:

if ( (parseInt(value.substr(6,2))+1900) % 4 == 0 || ((parseInt(value.substr(6,2))+1900) % 100 == 0 && (parseInt(value.substr(6,2))+1900) % 4 == 0 )){

ereg=/^[1-9][0-9]{5}[0-9]{2}((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))[0-9]{3}$/;//测试出生日期的合法性

} else {

ereg=/^[1-9][0-9]{5}[0-9]{2}((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|1[0-9]|2[0-8]))[0-9]{3}$/;//测试出生日期的合法性

}

if(ereg.test(value)) {
	
    validator.showErrors(); 
    return true;
}

else {
	this.settings.messages[element.name] =Errors[2]; 
	errMsg[element.name] =Errors[2];
	validator.showErrors(errMsg);
	return false;
	
};

break;

case 18:

//18位身份号码检测

//出生日期的合法性检查 

//闰年月日:((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))

//平年月日:((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|1[0-9]|2[0-8]))

if ( parseInt(value.substr(6,4)) % 4 == 0 || (parseInt(value.substr(6,4)) % 100 == 0 && parseInt(value.substr(6,4))%4 == 0 )){

ereg=/^[1-9][0-9]{5}19[0-9]{2}((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))[0-9]{3}[0-9Xx]$/;//闰年出生日期的合法性正则表达式

} else {

ereg=/^[1-9][0-9]{5}19[0-9]{2}((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|1[0-9]|2[0-8]))[0-9]{3}[0-9Xx]$/;//平年出生日期的合法性正则表达式

}

if(ereg.test(value)){//测试出生日期的合法性

//计算校验位

S = (parseInt(value_array[0]) + parseInt(value_array[10])) * 7

+ (parseInt(value_array[1]) + parseInt(value_array[11])) * 9

+ (parseInt(value_array[2]) + parseInt(value_array[12])) * 10

+ (parseInt(value_array[3]) + parseInt(value_array[13])) * 5

+ (parseInt(value_array[4]) + parseInt(value_array[14])) * 8

+ (parseInt(value_array[5]) + parseInt(value_array[15])) * 4

+ (parseInt(value_array[6]) + parseInt(value_array[16])) * 2

+ parseInt(value_array[7]) * 1

+ parseInt(value_array[8]) * 6

+ parseInt(value_array[9]) * 3 ;

Y = S % 11;

M = "F";

JYM = "10X98765432";

M = JYM.substr(Y,1);//判断校验位

if(M == value_array[17]){
	 
    validator.showErrors(); 
    return true;
} //检测ID的校验位

else {
	this.settings.messages[element.name] =Errors[3]; 
	errMsg[element.name] =Errors[3];
	validator.showErrors(errMsg);
	return false;
	
}

}

else {
	this.settings.messages[element.name] =Errors[2]; 
	errMsg[element.name] =Errors[2];
	validator.showErrors(errMsg);
	return false;
	
	
};

break;

default:

{
	this.settings.messages[element.name] =Errors[1]; 
	errMsg[element.name] =Errors[1];
	validator.showErrors(errMsg);
	return false;
};

break;

}



								
								
								 
							},
							
//========================================================================================

					remoteMsg : function(value, element, param) {
								
								if (this.optional(element))
									return "dependency-mismatch";
								var previous = this.previousValue(element);
								//if (!this.settings.messages[element.name])
									this.settings.messages[element.name] = {};
								this.settings.messages[element.name].remote = typeof previous.message == "function" ? previous
										.message(value)
										: previous.message;
								 
								this.settings.messages[element.name].remoteMsg = previous.message;
								param = typeof param == "string" && {
									url : param
								} || param;
								if (previous.old !== value) {
									previous.old = value;
									var validator = this;
									this.startRequest(element);
									var data = {};
									//data = param.data;
									data[element.name] = value;
									data['cardInfo.PAPER_TYPE'] = 'test';
									//000
									
									$.ajax($.extend(
  true,
  {
  url : param,
  mode : "abort",
  port : "validate" + element.name,
  dataType : "json",
  data : param.data,
  success : function(response) { 
    var valid = response ===true; 
    var submitted = validator.formSubmitted;
    validator.prepareElement(element);
    validator.formSubmitted = submitted; 
    validator.successList .push(element); 
    validator.showErrors(); 
    previous.valid = true;
    validator.stopRequest(element,true);
    },
  error: function(a,b,c){
	var errors = {};	
	previous.message=a.responseText;
	errors[element.name] =a.responseText;
	validator.showErrors(errors); 
    previous.valid = false; 
    validator .stopRequest(element, false);
    }
   }, param));


									//000
									return "pending";
								} else if (this.pending[element.name]) {
									return "pending";
								}
								return previous.valid;
							},
//============================================================================================
							remote : function(value, element, param) {
								if (this.optional(element))
									return "dependency-mismatch";
								var previous = this.previousValue(element);
								if (!this.settings.messages[element.name])
									this.settings.messages[element.name] = {};
								this.settings.messages[element.name].remote = typeof previous.message == "function" ? previous
										.message(value)
										: previous.message;
								param = typeof param == "string" && {
									url : param
								} || param;
								if (previous.old !== value) {
									previous.old = value;
									var validator = this;
									this.startRequest(element);
									var data = {};
									data[element.name] = value;
									$
											.ajax($
													.extend(
															true,
															{
																url : param,
																mode : "abort",
																port : "validate"
																		+ element.name,
																dataType : "json",
																data : data,
																success : function(
																		response) {
																	var valid = response === true;
																	if (valid) {
																		var submitted = validator.formSubmitted;
																		validator
																				.prepareElement(element);
																		validator.formSubmitted = submitted;
																		validator.successList
																				.push(element);
																		validator
																				.showErrors();
																	} else {
																		var errors = {};
																		errors[element.name] = previous.message = response
																				|| validator
																						.defaultMessage(
																								element,
																								"remote");
																		validator
																				.showErrors(errors);
																	}
																	previous.valid = valid;
																	validator
																			.stopRequest(
																					element,
																					valid);
																}
															}, param));
									return "pending";
								} else if (this.pending[element.name]) {
									return "pending";
								}
								return previous.valid;
							},
							minlength : function(value, element, param) {
								return this.optional(element)
										|| this.getLength($.trim(value),
												element) >= param;
							},
							maxlength : function(value, element, param) {
								return this.optional(element)
										|| this.getLength($.trim(value),
												element) <= param;
							},
							rangelength : function(value, element, param) {
								var length = this.getLength($.trim(value),
										element);
								return this.optional(element)
										|| (length >= param[0] && length <= param[1]);
							},
							min : function(value, element, param) {
								return this.optional(element) || value >= param;
							},
							max : function(value, element, param) {
								return this.optional(element) || value <= param;
							},
							range : function(value, element, param) {
								return this.optional(element)
										|| (value >= param[0] && value <= param[1]);
							},
							email : function(value, element) {
								return this.optional(element)
										|| /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$/i
												.test(value);
							},
							url : function(value, element) {
								return this.optional(element)
										|| /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i
												.test(value);
							},
							date : function(value, element) {
								return this.optional(element)
										|| !/Invalid|NaN/.test(new Date(value));
							},
							dateISO : function(value, element) {
								return this.optional(element)
										|| /^\d{4}[\/-]\d{1,2}[\/-]\d{1,2}$/
												.test(value);
							},
							dateDE : function(value, element) {
								return this.optional(element)
										|| /^\d\d?\.\d\d?\.\d\d\d?\d?$/
												.test(value);
							},
							number : function(value, element) {
								return this.optional(element)
										|| /^-?(?:\d+|\d{1,3}(?:,\d{3})+)(?:\.\d+)?$/
												.test(value);
							},
							numberDE : function(value, element) {
								return this.optional(element)
										|| /^-?(?:\d+|\d{1,3}(?:\.\d{3})+)(?:,\d+)?$/
												.test(value);
							},
							digits : function(value, element) {
								return this.optional(element)
										|| /^\d+$/.test(value);
							},
							creditcard : function(value, element) {
								if (this.optional(element))
									return "dependency-mismatch";
								if (/[^0-9-]+/.test(value))
									return false;
								var nCheck = 0, nDigit = 0, bEven = false;
								value = value.replace(/\D/g, "");
								for (n = value.length - 1; n >= 0; n--) {
									var cDigit = value.charAt(n);
									var nDigit = parseInt(cDigit, 10);
									if (bEven) {
										if ((nDigit *= 2) > 9)
											nDigit -= 9;
									}
									nCheck += nDigit;
									bEven = !bEven;
								}
								return (nCheck % 10) == 0;
							},
							accept : function(value, element, param) {
								param = typeof param == "string" ? param
										.replace(/,/g, '|') : "png|jpe?g|gif";
								return this.optional(element)
										|| value.match(new RegExp(".(" + param
												+ ")$", "i"));
							},
							equalTo : function(value, element, param) {
								return value == $(param).val();
							}
						}
					});
	$.format = $.validator.format;
})(jQuery);;
(function($) {
	var ajax = $.ajax;
	var pendingRequests = {};
	$.ajax = function(settings) {
		settings = $.extend(settings, $.extend( {}, $.ajaxSettings, settings));
		var port = settings.port;
		if (settings.mode == "abort") {
			if (pendingRequests[port]) {
				pendingRequests[port].abort();
			}
			return (pendingRequests[port] = ajax.apply(this, arguments));
		}
		return ajax.apply(this, arguments);
	};
})(jQuery);;
(function($) {
	$.each( {
		focus : 'focusin',
		blur : 'focusout'
	}, function(original, fix) {
		$.event.special[fix] = {
			setup : function() {
				if ($.browser.msie)
					return false;
				this.addEventListener(original, $.event.special[fix].handler,
						true);
			},
			teardown : function() {
				if ($.browser.msie)
					return false;
				this.removeEventListener(original,
						$.event.special[fix].handler, true);
			},
			handler : function(e) {
				arguments[0] = $.event.fix(e);
				arguments[0].type = fix;
				return $.event.handle.apply(this, arguments);
			}
		};
	});
	$.extend($.fn, {
		delegate : function(type, delegate, handler) {
			return this.bind(type, function(event) {
				var target = $(event.target);
				if (target.is(delegate)) {
					return handler.apply(target, arguments);
				}
			});
		},
		triggerEvent : function(type, target) {
			return this.triggerHandler(type, [ $.event.fix( {
				type : type,
				target : target
			}) ]);
		}
	})
})(jQuery);